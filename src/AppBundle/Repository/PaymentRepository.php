<?php

namespace AppBundle\Repository;

/**
 * PaymentRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PaymentRepository extends \Doctrine\ORM\EntityRepository
{

    public function getUnsuccessfulEuroPayments()
    {
        return $this->getPayments(0, 'EUR');
    }

    public function getWeeklySuccessStatistics()
    {
        return $this->getStatistics(7, 1);
    }

    protected function getPayments($status = 0, $currencyCode = 'EUR')
    {

        /*
         *    Тезисно:
         *
         *    Основной лейтмотив - максимально возможный отказ от подзапросов и join'ов, лучший вариант для конкретной
         *    задачи - отдельная табличка для последних неудачных платежей в EUR (если интересует исключительно EUR),
         *
         *
         *    Подробно:
         *
         * 1) Оптимизация таблицы payments (навесить индексы, оптимизировать запросы и подзапросы, что бы все
         *    работали по индексам) несомненно дает эффект, то только кратковременный.
         *    С увеличением количества записей будут возрастать и затрачиваемые ресурсы, необходимое на выполнение.
         *
         * 2) Если нет строгости в сиюсекундной актуальности данных, то что бы избежать блокировки таблицы и
         *    снизить нагрузку, можно сделать репликацию master-slave и служебные запросы выполнять на slave-базе.
         *
         * 3) Для повышения производительности работы базы можно применить шардинг базы данных, но тут нужно
         *    подходить с пониманием всей архитектуры, так как при горизонтальном сложно будет делать общие выборки,
         *    а при вертикальном - join'ы
         *
         * 4) Можно сделать хранимую процедуру, которая будет выполнять данную выборку, перенести логику
         *    из фреймворка в БД, такая рутина будет выполняться быстрее, но все равно не решает
         *    основную проблему - дергать все многомилионное разнообразие наших записей.
         *
         * 5) Довольно накладная операция пересчетиа суммы платежа в эквивалентной сумме в гривнах,
         *    если гривна принята в проекте как базовая учетная валюта, то логично добавить колонку,
         *    в которой будет храниться сумма уже приведенная к сумме учетной валюты, или как минимум добавить
         *    в таблицу payments колонку currency_rate_id, что бы связать обе таблички, но от join'а все равно
         *    так будет не уйти, поэтому лучше хранить дополнительно уже приведенную в учетную валюту сумму
         *    в самой таблице payments
         *
         * 6) Еще одно решение - пойти по пути денормализации БД.
         *    Для данной задачи необходимо доработать структуру базы, таблица payments - остается архивной таблицей,
         *    которая служит для хранения истории платежей.
         *    Если же нам нужно формировать отчеты по неудачным платежам, при этом, такие отчеты формируются
         *    на постоянной основе, то имеет смысл завести отдельную таблицу под неудавшиеся последние платежи,
         *    запись из которой по пользователю удалялась бы в случае успешности его последнего платежа.
         *    В данном случае, избыточность данных будет являться оправданной.
         *
         *    Ну и комбинацию предложенных вариантов никто не отменял.
         *
         * */

        $conn = $this->getEntityManager()->getConnection();
        $sql = 'SELECT u.id user_id, u.name user_name, p.currency_code, p.amount, ROUND(p.amount*r.rate,2) uah, p.created_at
                  FROM payments p
                  JOIN (
                       SELECT user_id, MAX(created_at) AS last
                       FROM payments
                       GROUP BY user_id
                       ) j
                    ON p.user_id = j.user_id
                        AND p.created_at = j.last
                  LEFT JOIN users u 
                    ON u.id = p.user_id
                  LEFT JOIN currency_rates r 
                    ON r.currency_code = p.currency_code AND r.date = DATE_FORMAT(p.created_at, "%Y-%c-%d")
                  WHERE p.status = :status
                    AND p.currency_code = :currencyCode';

        $sth = $conn->prepare($sql);
        $sth->execute(array(':status' => $status, ':currencyCode' => $currencyCode));

        return $sth->fetchAll();
    }

    protected function getStatistics($date_diff = 7, $status = 1)
    {


        /*
         *    Тезисно:
         *
         *    Тут аналогичная ситуация - максимально возможный отказ от подзапросов и join'ов, лучший вариант -
         *    отдельная табличка для статистики
         *
         *
         *    Подробно:
         *
         * 1) В целом, рекомендации по отказу от лишних join'ов с прошлой таблицы применимы и к этой, что бы избавиться
         *    от него, достаточно сразу при создании платежа вносить информацию в гривневом эквиваленте
         *
         * 2) Рекомендация по созданию репликации и работы со slave-сервером для отчетов применима и к этой таблице
         *
         * 3) Оптимизацию можно начать с создания индексов. Завести индекс "Day" с типом date (yyyy-mm-dd) и
         *    делать выборку по этому полю, тогда запрос по конкретным дням будет работать быстрее. В конкретно
         *    поставленной задачи, индекс можно будет создать на Day+Status
         *
         * 4) Можно задействовать партиционирование таблицы по дням, тем самым, при выборке конкретных дней поиск
         *    будет происходить в конкретных физических файлах на диске.
         *
         * 5) Если формирование подобной статистики является периодическим, то лучшим вариантом будет завести
         *    отдельную служебную таблицу с отчетами, и кроном выполнять ежедневную рутину по сбору статистики за сутки,
         *    и выборку выборку статистики выполнять уже с этой служебной таблицы.
         *
         *    Если нужна информация, включая текущий день, в онлайн-режиме, к примеру, для вывода информера
         *    для посетителей, то можно кроном настроить обновление данных служебной таблицы через заданный
         *    промежуток времени (к примеру, каждые 30 минут), вплоть до ежеминутного обновления, для этого добавляется
         *    в таблицу статистики last_id, который в строку за текущий день будет добавлять сумму с архивной таблицы
         *    только по новым записям payments.id > stat.last_id)
         *
         *    Опять же, самым быстрым и эффективным вариантом остается денормализация с периодическим сбросом в нее
         *    статистики с основной таблицы по отбору payments.id > stat.last_id с той периодичностью синхронизации,
         *    которая нам требуется
         *
         * */

        $conn = $this->getEntityManager()->getConnection();
        $sql = 'SELECT DATE_FORMAT(created_at, "%d.%m.%Y") day, ROUND(SUM(p.amount*r.rate),2) sum
                  FROM payments p
                  LEFT JOIN currency_rates r 
                    ON r.currency_code = p.currency_code AND r.date = DATE_FORMAT(p.created_at, "%Y-%c-%d")
                  WHERE DATEDIFF(p.created_at, CURRENT_DATE()) <= :date_diff AND status = :status
                  GROUP BY day
                  WITH ROLLUP';

        $sth = $conn->prepare($sql);
        $sth->execute(array(':date_diff' => $date_diff, ':status' => $status));

        return $sth->fetchAll();

    }
}
